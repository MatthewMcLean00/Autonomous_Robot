#pragma config(Sensor, in1,    IR_MID,         sensorReflection)
#pragma config(Sensor, in2,    IR_R,           sensorReflection)
#pragma config(Sensor, in3,    IR_L,           sensorReflection)
#pragma config(Sensor, in8,    POTENT,         sensorPotentiometer)
#pragma config(Sensor, dgtl1,  BUTT,           sensorTouch)
#pragma config(Sensor, dgtl5,  SONAR,          sensorSONAR_cm)
#pragma config(Sensor, dgtl10, IR_INDICATOR,   sensorDigitalOut)
#pragma config(Sensor, dgtl11, SONAR_INDICATOR, sensorDigitalOut)
#pragma config(Motor,  port1,           MOTOR_L,       tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           MOTOR_ARM,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          MOTOR_R,       tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

typedef enum T_State {
	NO_BUTT = 0,
	SEARCHING,
	CHASING,
	PRETTY_CLOSE,
	CLOSE,
	CONNECTION,
	DONE,
	DONE_PT2
};

int beacon_MID_threshold = 10;
bool butt_pushed;


void monitor_Butt()
{
	if(SensorValue(BUTT)&& !butt_pushed)
	{
		butt_pushed = true;
	}
}

int monitor_IR_Light_MID()
{
	static int minLevel_IR_MID = 4096;
	static int maxLevel_IR_MID = 0;
	static int diffLevel_IR_MID = 0;

	int lightLevel_IR_MID = SensorValue[IR_MID];

	if ( time1[T1] > 100 )  {

		diffLevel_IR_MID = maxLevel_IR_MID - minLevel_IR_MID;

		maxLevel_IR_MID = 0;
		minLevel_IR_MID = 4096;
		clearTimer(T1);

		} else {

		if ( lightLevel_IR_MID < minLevel_IR_MID ) {
			minLevel_IR_MID = lightLevel_IR_MID;
			}
		else if ( lightLevel_IR_MID > maxLevel_IR_MID ) {
			maxLevel_IR_MID = lightLevel_IR_MID;
		}
	}

	return(diffLevel_IR_MID);
}

int monitor_IR_Light_L()
{
	static int minLevel_IR_L = 4096;
	static int maxLevel_IR_L = 0;
	static int diffLevel_IR_L = 0;

	int lightLevel_IR_L = SensorValue[IR_L];

	if ( time1[T1] > 100 )  {

		diffLevel_IR_L = maxLevel_IR_L - minLevel_IR_L;

		maxLevel_IR_L = 0;
		minLevel_IR_L = 4096;
		clearTimer(T1);

		} else {

		if ( lightLevel_IR_L < minLevel_IR_L ) {
			minLevel_IR_L = lightLevel_IR_L;
			}
		else if ( lightLevel_IR_L > maxLevel_IR_L ) {
			maxLevel_IR_L = lightLevel_IR_L;
		}
	}

	return(diffLevel_IR_L);
}

int monitor_IR_Light_R()
{
	static int minLevel_IR_R = 4096;
	static int maxLevel_IR_R = 0;
	static int diffLevel_IR_R = 0;

	int lightLevel_IR_R = SensorValue[IR_R];

	if ( time1[T1] > 100 )  {

		diffLevel_IR_R = maxLevel_IR_R - minLevel_IR_R;

		maxLevel_IR_R = 0;
		minLevel_IR_R = 4096;
		clearTimer(T1);

		} else {

		if ( lightLevel_IR_R < minLevel_IR_R ) {
			minLevel_IR_R = lightLevel_IR_R;
			}
		else if ( lightLevel_IR_R > maxLevel_IR_R ) {
			maxLevel_IR_R = lightLevel_IR_R;
		}
	}

	return(diffLevel_IR_R);
}

task main()
{
	T_State robot_state = NO_BUTT;
	int  beacon_level_MID;
	int beacon_level_L;
	int beacon_level_R;

	while( true ) {

		beacon_level_MID = monitor_IR_Light_MID();
		beacon_level_L = monitor_IR_Light_L();
		beacon_level_R = monitor_IR_Light_R();
		monitor_Butt();

		switch( robot_state ) {

		case NO_BUTT:
			SensorValue[IR_INDICATOR] = 0;
			SensorValue[SONAR_INDICATOR] = 0;
			motor[MOTOR_L] = 0;
			motor[MOTOR_R] = 0;
			if(butt_pushed){
				butt_pushed = false;
				robot_state = SEARCHING;
			}

			if(SensorValue[POTENT] > 2600)
				motor[MOTOR_ARM] = -25;
			else{
				motor[MOTOR_ARM] = 0;
			}

		break;

		case SEARCHING:
			SensorValue[IR_INDICATOR] = 0;
			SensorValue[SONAR_INDICATOR] = 0;
			motor[MOTOR_L] = 37;
			motor[MOTOR_R] = -30;
			if ( beacon_level_MID > beacon_MID_threshold ) {
				robot_state = CHASING;
				} else {
				robot_state = SEARCHING;

			}

		break;

		case CHASING:
			SensorValue[IR_INDICATOR] = 1;
			SensorValue[SONAR_INDICATOR] = 0;
			motor[MOTOR_L] = 60;
			motor[MOTOR_R] = 55;

			if(SensorValue[SONAR] < 100){
				beacon_MID_threshold = 20;
			}

			if ( beacon_level_MID > beacon_MID_threshold ) {
				robot_state = CHASING;
				} else {
				robot_state = SEARCHING;
			}

			if(SensorValue[SONAR] < 50 && beacon_level_MID > beacon_MID_threshold){
				beacon_MID_threshold = 75;
				robot_state = PRETTY_CLOSE;
			}
			break;

		case PRETTY_CLOSE:

			if (beacon_level_MID > beacon_MID_threshold)
			{
					motor[MOTOR_L] = 36;
					motor[MOTOR_R] = 30;
				}
				else
					robot_state = SEARCHING;

			if(beacon_level_L > beacon_level_R + 40){
				motor[MOTOR_L] = 28;
				motor[MOTOR_R] = 35;
			}
			else if (beacon_level_L + 40 < beacon_level_R){
				motor[MOTOR_L] = 35;
				motor[MOTOR_R] = 20;
			}
			else {
				motor[MOTOR_L] = 36;
				motor[MOTOR_R] = 30;
			}
			 if(SensorValue[SONAR] < 15  ){
				robot_state = CLOSE;
			}
		break;

		case CLOSE:
			SensorValue[IR_INDICATOR] = 1;
			SensorValue[SONAR_INDICATOR] = 1;
			motor[MOTOR_L] = 0;
			motor[MOTOR_R] = 0;
			resetMotorEncoder(MOTOR_ARM);
			robot_state = CONNECTION;
		  break;

		case CONNECTION:
			SensorValue[IR_INDICATOR] = 1;
			SensorValue[SONAR_INDICATOR] = 1;
			if(SensorValue[POTENT] < 3800)
				motor[MOTOR_ARM] = 14;
			else if(SensorValue[POTENT] >= 3800){
				robot_state = DONE;
			break;

		case DONE:
			SensorValue[IR_INDICATOR] = 1;
			SensorValue[SONAR_INDICATOR] = 1;
			motor[MOTOR_ARM] = 0;
			motor[MOTOR_L] = -33;
			motor[MOTOR_R] = -30;
			wait1Msec(2500);
			motor[MOTOR_L] = -45;
			motor[MOTOR_R] = -20;
			wait1Msec(2500);
			motor[MOTOR_L] = 55;
			motor[MOTOR_R] = 55;
			wait1Msec(2000);
			robot_state = DONE_PT2;
		break;

		case DONE_PT2:
			SensorValue[IR_INDICATOR] = 1;
			SensorValue[SONAR_INDICATOR] = 1;
			motor[MOTOR_ARM] = 0;
			motor[MOTOR_L] = 0;
			motor[MOTOR_R] = 0;
			wait1Msec(100);
			SensorValue[IR_INDICATOR] = 0;
			SensorValue[SONAR_INDICATOR] = 0;
			wait1Msec(100);
		break;

		default:
			// This should never happen.
			robot_state = SEARCHING;

		} // switch( robot_state)
	}

	}  // while(true)

}
